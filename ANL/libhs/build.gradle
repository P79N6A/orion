import javax.crypto.Cipher
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey

apply plugin: 'com.android.library'

android {
    compileSdkVersion 27

    defaultConfig {
        minSdkVersion 19
        targetSdkVersion 27
        versionCode 100007
        versionName "1.0.7"
        externalNativeBuild {
            cmake {
                cppFlags "-std=c++14"
                abiFilters "arm64-v8a", "armeabi-v7a", "x86_64"
            }
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }

    libraryVariants.all { variant ->
        variant.outputs.all { output ->
            if (output.outputFile != null && output.outputFile.name.endsWith('.aar')) {
                if (output.outputFile.name.contains(variant.buildType.name)) {
                    def versionName = defaultConfig.versionName;
                    outputFileName = "libhs-${versionName}-${variant.buildType.name}.aar"
                }
            }
        }
    }

    externalNativeBuild {
        cmake {
            path "CMakeLists.txt"
        }
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    implementation('com.android.support:support-v4:27.1.0') {
        exclude group: 'com.android.support', module: 'support-core-ui'
        exclude group: 'com.android.support', module: 'support-media-compat'
        exclude group: 'com.android.support', module: 'support-fragment'
    }
}

def writeEnc(dstFile, plainBytes, microName, arrayName, sizeName) {
    KeyGenerator rc4KeyGenerator = KeyGenerator.getInstance("RC4");
    SecretKey key = rc4KeyGenerator.generateKey()

    Cipher cipher = Cipher.getInstance("RC4")
    cipher.init(Cipher.ENCRYPT_MODE, key)
    byte[] cipherBytes = cipher.doFinal(plainBytes)

    StringBuilder content = new StringBuilder()
    FileOutputStream fos = new FileOutputStream(dstFile)

    content.append("#ifndef ").append(microName).append("\n#define ")
            .append(microName).append("\n\nconst unsigned char ")
            .append(arrayName).append("[] = {")
    char[] DIGITS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f']
    for (int i = 0; i < cipherBytes.length; ) {
        if ((i % 16) == 0) {
            content.append("\n")
        }

        for (int j = 0; j < 16 && i < cipherBytes.length; j++) {
            byte b = cipherBytes[i++]
            content.append('0x')
            content.append(DIGITS[(b >>> 4) & 0x0F])
            content.append(DIGITS[b & 0x0F])
            content.append(', ')
        }
    }
    content.append("\n");

    byte[] keyBytes = key.getEncoded()
    for (int k = 0; k <  keyBytes.length; k++) {
        byte b = keyBytes[k]
        content.append('0x')
        content.append(DIGITS[(b >>> 4) & 0x0F])
        content.append(DIGITS[b & 0x0F])
        content.append(', ')
    }
    content.append("\n};\n")

    content.append("\nconst int keySize = " + keyBytes.length + ";\n" + "const int ")
            .append(sizeName).append(" = sizeof(").append(arrayName).append(")/sizeof(")
            .append(arrayName).append("[0]);\n\n#endif // ").append(microName).append("\n")
    // println content

    fos.write(content.toString().getBytes("utf-8"))
    fos.close()
}

task genCLDHeaderFile {
    try {
        int n
        def jarFile = file('src/main/cpp/cld.apk')
        if (!jarFile.exists())
            return

        FileInputStream fis = new FileInputStream(jarFile)
        ByteArrayOutputStream baos = new ByteArrayOutputStream()

        byte[] buf = new byte[4096]
        while ((n = fis.read(buf)) > 0) {
            baos.write(buf, 0, n)
        }
        fis.close()
        writeEnc(file('src/main/cpp/cldata.h'), baos.toByteArray(), "CLDATA_H", "cldata", "cldsize")
        baos.close()
    }  catch (Exception e) {
        e.printStackTrace()
    }
}

task genQHeaderFile {
    try {
        int n
        def jarFile = file('src/main/cpp/q.apk')
        if (!jarFile.exists())
            return

        FileInputStream fis = new FileInputStream(jarFile)
        ByteArrayOutputStream baos = new ByteArrayOutputStream()

        byte[] buf = new byte[4096]
        while ((n = fis.read(buf)) > 0) {
            baos.write(buf, 0, n)
        }
        fis.close()
        writeEnc(file('src/main/cpp/qdata.h'), baos.toByteArray(), "QDATA_H", "qdata", "qsize")
        baos.close()
    }  catch (Exception e) {
        e.printStackTrace()
    }
}

genQHeaderFile.dependsOn genCLDHeaderFile
preBuild.dependsOn genQHeaderFile



apply plugin: 'com.github.dcendents.android-maven'
apply plugin: 'com.jfrog.bintray'

group = 'com.hs.lib'   // library库包名
version = '1.0.7'      // 版本号

task generateSourcesJar(type: Jar) {
    from android.sourceSets.main.java.srcDirs
    classifier'sources'
}

task generateJavadocs(type: Javadoc) {
    source = android.sourceSets.main.java.srcDirs
    classpath += project.files(android.getBootClasspath()
            .join(File.pathSeparator)) //使用android.getBootClasspath关联Android SDK类文件
}

task generateJavadocsJar(type: Jar) {
    from generateJavadocs.destinationDir
    classifier'javadoc'
}

generateJavadocsJar.dependsOn generateJavadocs

artifacts {
    archives generateJavadocsJar
    archives generateSourcesJar
}

bintray {
    user = 'zhangheng1983' //在个人中心的路径里可以找到
    key = 'cb446f60d9b4b88a5b40201c0ba2a719fff5b867' //上述保存的API key
    pkg {
        repo ='maven' //必须设定一个值，这里选择maven
        name ='com.hs.lib' //必须，包名
        version {
            name ='1.0.7' //版本名称
            released = new Date() //上传过程中如果此处报错，可以注释掉此句
            vcsTag ='1.0.7' //版本
        }
        licenses = ['Apache-2.0'] //开源协议
        vcsUrl = '' //指定项目git地址
        websiteUrl = '' //项目官网地址
    }
    configurations = ['archives'] //必须为archives
}
